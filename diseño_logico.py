# -*- coding: utf-8 -*-
"""Dise√±o Logico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14jA_QMqr71HOJNXy1VXof4dWBjjUmjus

***MECANISMO DE SUMA BINARIA*** üíª üî¢
---
---
*por Johan, Dylier y Michael - 19 Agos - 2024*

**Descripcion:** Resolver y desarrollar un mecanismo de suma para n numeros de m bits que muestre el procedimiento en binario y muestre el resultado en decimal, la longitud de los numeros son de 8, 16 y 24 bits.

**Ejemplo de uso:** Digamos que yo ingreso 9 numeros, el numero A, B y C de 8 bits, los D y E de 16 bits, y los F, G, H e I de 24 bits. Debo poder sumarlos entre si al mismo tiempo.


```
   8 bits -> A, B, C
  16 bits -> D, E
  24 bits -> F, G, H, I

  sumar D y H
  sumar D, E, F y G
```
**Desarrollo:** Se identificaron 4 modulos de codigo necesarios para el programa

# **Codigo para guardar datos** üíæ
"""

lista_datos = [
    "111111111111111111001111",
    "111111111111111111111000",
    "111111111111111111111100",
    "111111111111111000111111",
    "111111111111111111110111",
    "1111111111110000",
    "1111111111111110",
    "1111111111000111",
    "1111111111111000",
    "11111000",
    "11111100",
    "11111110"
]
def guardar_datos(bits, valor_binario):
    if not all(char in '01' for char in valor_binario):
        print("El valor ingresado no es un n√∫mero binario v√°lido. Solo se permiten '0' y '1'.")
        return

    if len(valor_binario) <= bits:
        valor_binario = valor_binario.zfill(bits) # por si acaso, zfill solo agrega 0 al inicio del texto
        lista_datos.append(valor_binario)
        print(f"se ha guardado {valor_binario} de tama√±o de {bits} bits")
    else:
        print(f"no se ha agregado el valor porque no cumple con el tama√±o en bits")

"""# **Codigo para pasar de binario a decimal** üíΩ"""

def binarioaDecimal(num):
    # Invertir la cadena para operar de derecha a izquierda
    numInvertido = num[::-1]
    expo = 0  # Exponente que incrementa seg√∫n el n√∫mero de d√≠gitos/bits
    base = 2  # Base original del n√∫mero, en este caso 2 (binario)
    resultado = 0  # Variable para almacenar la suma total
    print("---------------------\n")
    # Recorrer cada d√≠gito en el n√∫mero invertido
    for n in numInvertido:
        print(f"{n} * {base}^{expo} = {int(n) * (base ** expo)}")
        resultado += int(n) * (base ** expo)
        expo += 1  # Incrementar el exponente para el siguiente d√≠gito
    print(f"{num} en base {base} == {resultado} decimal")
    print("---------------------\n")


    return resultado  # Retornar el valor en decimal

# # uso:
# numeroBinario = input("Ingrese un n√∫mero binario: ")
# resultadoDecimal = binarioaDecimal(numeroBinario)
# print("El n√∫mero en decimal es:", resultadoDecimal)

"""# **Codigo para realizar suma binaria** ‚ûï üî¢"""

import  os, time
def suma_binaria(sublista):
    def reemplazar_posicion(cadena, posicion, nuevo_caracter):
        lista = list(cadena)
        lista[posicion] = nuevo_caracter if lista[posicion] != "0" else "0"
        return ''.join(lista)

    max_len = max(len(x) for x in sublista)
    sublista_invertida = [x.zfill(max_len)[::-1] for x in sublista]

    resultado = []
    acarreo = 0

    for posicion in range(max_len):
        suma = acarreo

        for i, numero in enumerate(sublista_invertida):
            suma += int(numero[posicion])
            #os.system("clear")
            print(f"\n suma = {suma} acarreo = {acarreo}\n")
            for inv, ori in zip(sublista_invertida, sublista):
                if inv == numero:
                    print(reemplazar_posicion(numero, posicion, "*")[::-1].replace("0"," ", max_len - len(ori)) + "-->" + str(suma))
                    imp = inv
                else:
                    print(inv[::-1].replace("0"," ", max_len - len(ori)))
            print("-"*max_len)
            print("".join(resultado)[::-1].rjust(max_len))
            # time.sleep(0.1) if i == 0 else time.sleep(0.3)



        bit_resultante = suma % 2
        acarreo = suma // 2
        resultado.append(str(bit_resultante))

    while acarreo > 0:
        resultado.append(str(acarreo % 2))
        acarreo //= 2
    resultado_final = ''.join(resultado[::-1])

    os.system("clear")
    for impreso in sublista_invertida:
        print(impreso[::-1])
    print("-"*max_len)
    print(resultado_final)
    print("\nResultado final de la suma en binario:", resultado_final)

    return resultado_final

# sublista = ["101", "10101", "1011101"]
# suma_binaria(sublista)

"""# **Codigo para validar suma decimal** ‚è´"""

def validacion_suma(sublista, resultado_decimal_de_binario):
    suma_decimal = sum(binarioaDecimal(num) for num in sublista)

    print("\n--- Validacion de la Suma ---")
    print(f"Suma en decimal: {suma_decimal}")
    print(f"Suma validada en binario: {resultado_decimal_de_binario}")

    if suma_decimal == resultado_decimal_de_binario:
        print("La suma binaria es correcta.")
        return True
    else:
        print("Error en la suma binaria.")
        return False

"""# **Codigo ejecutable** üá≤

## ***Metodos***

### Metodo mostrar menu
"""

def mostrar_menu():
    print("\nMen√∫ Principal")
    print("1. Guardar nuevo valor binario")
    print("2. Seleccionar valores y sumar")
    print("3. Salir")

"""### Metodo seleccionar valores"""

def seleccionar_valores():
    if not lista_datos:
        print("No hay valores almacenados.")
        return []

    print("\nLista de valores binarios almacenados:")
    for i, valor in enumerate(lista_datos):
        print(f"{i + 1}. {valor}")

    indices = input("Ingrese los n√∫meros de los valores que desea sumar, separados por comas: ")
    indices = indices.split(',')

    sublista = []
    for i in indices:
        try:
            sublista.append(lista_datos[int(i) - 1])
        except (ValueError, IndexError):
            print(f"√çndice {i} no v√°lido.")

    return sublista

"""## ***Codigo Main***"""

def main():
    while True:
        mostrar_menu()
        opcion = input("Seleccione una opci√≥n: ")

        if opcion == "1":
            bits = int(input("Ingrese la cantidad de bits (8, 16, 24): "))
            if bits not in [8, 16, 24]:
                print("Valor inv√°lido. Solo se permiten valores de 8, 16, o 24 bits.")
                continue
            valor_binario = input(f"Ingrese el valor en binario para {bits} bits: ")
            guardar_datos(bits, valor_binario)

        elif opcion == "2":
            sublista = seleccionar_valores()
            if len(sublista) > 1:
                resultado_binario = suma_binaria(sublista)
                print("Conversion de la resultado binario a decimal")
                resultado_decimal = binarioaDecimal(resultado_binario)
                validacion_suma(sublista, resultado_decimal)
                print(f"\nEl resultado de la suma es: {resultado_binario} en binario y {resultado_decimal} en decimal.")
            else:
                print("Debe seleccionar al menos dos n√∫meros binarios para realizar la suma.")

        elif opcion == "3":
            print("Saliendo del programa.")
            break

        else:
            print("Opci√≥n no v√°lida. Por favor, intente nuevamente.")

if __name__ == "__main__":
    main()

"""# ***Prueba codigo***"""

def prueba_codigo():
    # Generar la lista total con todos los n√∫meros posibles de 8 bits binarios en strings
    total = [format(i, '08b') for i in range(30)]  # Genera n√∫meros binarios desde 0 a 255 en formato de 8 bits

    errores = []  # Lista para almacenar sublistas con errores

    for i in range(2, len(total) + 1):  # Comienza desde 2 para crear sublistas de al menos 2 elementos
        sub_lista = total[:i]  # Sublista con los primeros 'i' elementos de 'total'
        resultado_binario = suma_binaria(sub_lista)  # Suma los valores binarios de la sublista
        resultado_decimal = binarioaDecimal(resultado_binario)  # Convierte el resultado binario a decimal

        # Validaci√≥n de la suma en decimal
        if not validacion_suma(sub_lista, resultado_decimal):
            errores.append((sub_lista, resultado_binario, resultado_decimal))  # A√±adir la sublista a la lista de errores
        else:
            print(f"Sublista v√°lida: {sub_lista}")
            print(f"Resultado binario: {resultado_binario}, Resultado decimal: {resultado_decimal}")

    # Verificar si hubo errores y mostrarlos
    if errores:
        print("\nSe encontraron errores en las siguientes sublistas:")
        for error in errores:
            sub_lista, resultado_binario, resultado_decimal = error
            print(f"Sublista: {sub_lista}, Resultado binario incorrecto: {resultado_binario}, Resultado decimal incorrecto: {resultado_decimal}")
    else:
        print("\nTodas las sublistas se validaron correctamente.")